import Foundation
import UniformTypeIdentifiers

#if os(iOS) || os(watchOS) || os(tvOS)
import MobileCoreServices
#elseif os(macOS)
import CoreServices
#endif

struct Header: Hashable {

    let name: HTTPHeader
    let value: String

}

enum EncodingCharacters {
    static let crlf = "\r\n"
}

enum Boundary {

    enum `Type` {
        case initial
        case encapsulated
        case final
    }

    static func random() -> String {
        UUID().uuidString
    }

    static func string(for type: Boundary.`Type`, boundary: String) -> String {
        switch type {
        case .initial:
            return "--\(boundary)\(EncodingCharacters.crlf)"
        case .encapsulated:
            return "\(EncodingCharacters.crlf)--\(boundary)\(EncodingCharacters.crlf)"
        case .final:
            return "\(EncodingCharacters.crlf)--\(boundary)--\(EncodingCharacters.crlf)"
        }
    }

    static func data(for type: Boundary.`Type`, boundary: String) -> Data {
        let boundaryText = Self.string(for: type, boundary: boundary)

        return Data(boundaryText.utf8)
    }
}

struct BodyPart {

    let headers: [Header]
    let stream: InputStream
    let length: Int
    var hasInitialBoundary = false
    var hasFinalBoundary = false

    init(headers: [Header], stream: InputStream, length: Int) {
        self.headers = headers
        self.stream = stream
        self.length = length
    }

}

/// Constructs `multipart/form-data` for uploads within an HTTP or HTTPS body.
/// We encode the data directly in memory. It's very efficient, but can lead to memory issues if the dataset is too large (eg: a Video)
///
/// `Warning`: A Second approch to encode bigger dataset will be addes later

public struct MultipartFormData {

    let boundary: String
    let fileManager: FileManager
    var bodyParts = [BodyPart]()

    /// Creates an instance
    ///
    /// - Parameters:
    ///   - fileManager: `FileManager` to use for file operation, if needed
    ///   - boundary: `String` used to separate body parts
    public init(fileManager: FileManager = .default, boundary: String? = nil) {
        self.fileManager = fileManager
        self.boundary = boundary ?? Boundary.random()
    }

    /// Creates a body part from the file and add it to the instance
    ///
    /// The body part data will be encode by using this format:
    ///
    /// - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTPHeader)
    /// - `Content-Type: #{generated mimeType}` (HTTPHeader)
    /// - Encoded file data
    /// - Multipart form boundary
    ///
    /// The filename in the `Content-Disposition` HTTPHeader is generated from the last path component of the `fileURL`.
    /// The `Content-Type` HTTPHeader MIME type is generated by mapping the `fileURL` extension to the system associated MIME type.
    ///
    /// - Parameters:
    ///   - url: `URL` of the file to encoding into the instance
    ///   - name: `String` associated to the `Content-Disposition` HTTPHeader
    public mutating func add(url: URL, name: String) throws {
        let fileName = url.lastPathComponent
        let mimeType = mimeType(from: url)

        try add(url: url, name: name, fileName: fileName, mimeType: mimeType)
    }

    /// Creates a body part from the file and add it to the instance
    ///
    /// The body part data will be encode by using this format:
    ///
    /// - `Content-Disposition: form-data; name=#{name}; filename=#{generated filename}` (HTTPHeader)
    /// - `Content-Type: #{generated mimeType}` (HTTPHeader)
    /// - Encoded file data
    /// - Multipart form boundary
    ///
    /// The filename in the `Content-Disposition` HTTPHeader is generated from the last path component of the `fileURL`.
    /// The `Content-Type` HTTPHeader MIME type is generated by mapping the `fileURL` extension to the system associated MIME type.
    ///
    /// - Parameters:
    ///   - url: `URL` of the file to encoding into the instance
    ///   - name: `String` associated to the `Content-Disposition` HTTPHeader
    ///   - fileName: `String` associated to the `Content-Disposition` HTTPHeader
    ///   - mimeType: `String` associated to the `Content-Type` HTTPHeader
    public mutating func add(url: URL, name: String, fileName: String, mimeType: String) throws {
        let headers = defineBodyPartHeader(name: name, fileName: fileName, mimeType: mimeType)

        guard let fileSize = try fileManager.attributesOfItem(atPath: url.path)[.size] as? NSNumber else {
            throw MultipartFormData.Error.fileSizeNotAvailable(url)
        }

        let length = fileSize.intValue

        guard let stream = InputStream(url: url) else {
            throw MultipartFormData.Error.inputStreamCreationFailed(url)
        }

        bodyParts.append(BodyPart(headers: headers, stream: stream, length: length))
    }

    /// Creates a body part from the data and add it to the instance.
    ///
    /// The body part data will be encoded  by using this:
    ///
    /// - `Content-Disposition: form-data; name=#{name}; filename=#{filename}` (HTTPHeader)
    /// - `Content-Type: #{mimeType}` (HTTPHeader)
    /// - Encoded file data
    /// - Multipart form boundary
    ///
    /// - Parameters:
    ///   - data:     `Data` to encoding into the instance.
    ///   - name:     Name associated to the `Data` in the `Content-Disposition` HTTPHeader.
    ///   - fileName: Filename associated to the `Data` in the `Content-Disposition` HTTPHeader.
    ///   - mimeType: MIME type associated to the data in the `Content-Type` HTTPHeader.
    public mutating func add(data: Data, name: String, fileName: String? = nil, mimeType: String? = nil) {
        let headers = defineBodyPartHeader(name: name, fileName: fileName, mimeType: mimeType)
        let stream = InputStream(data: data)
        let length = data.count
        
        bodyParts.append(BodyPart(headers: headers, stream: stream, length: length))
    }

    private func defineBodyPartHeader(name: String, fileName: String?, mimeType: String?) -> [Header] {
        var headers = [Header]()
        var disposition = "form-data; name=\"\(name)\""

        if let fileName = fileName {
            disposition += "; filename=\"\(fileName)\""
        }

        headers.append(Header(name: .contentDisposition, value: disposition))

        if let mimeType = mimeType {
            headers.append(Header(name: .contentType, value: mimeType))
        }

        return headers
    }

    private func mimeType(from url: URL) -> String {
        if #available(iOS 14.0, *) {
            guard let type = UTType(filenameExtension: url.pathExtension), let mime = type.preferredMIMEType else {
                return HTTPContentType.octetStream.value
            }
            return mime
        } else {
            if let id = UTTypeCreatePreferredIdentifierForTag(kUTTagClassFilenameExtension, url.pathExtension as CFString, nil)?.takeRetainedValue(),
               let contentType = UTTypeCopyPreferredTagWithClass(id, kUTTagClassMIMEType)?.takeRetainedValue() {
                return contentType as String
            }
            return HTTPContentType.octetStream.value
        }
    }

}

public extension MultipartFormData {

    enum Error: Swift.Error {
        case fileSizeNotAvailable(URL)
        case inputStreamCreationFailed(URL)
    }

}
